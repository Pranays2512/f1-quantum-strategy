<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>F1 Quantum Strategy Simulator - Live Track Integration</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
   <style>
    :root {
        --f1-red: #e60000;
        --f1-red-dark: #b30000;
        --f1-black: #000000;
        --f1-white: #ffffff;
        --glass-bg: rgba(10, 10, 10, 0.75);
        --glass-border: rgba(230, 0, 0, 0.4);
    }
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    body {
        font-family: 'Orbitron', sans-serif;
        background: var(--f1-black);
        color: var(--f1-white);
        overflow-x: hidden;
    }
    .container {
        max-width: 1800px;
        margin: 0 auto;
        padding: 20px;
    }
    header, .track-container, .info-panel {
        background: var(--glass-bg);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border-radius: 15px;
        margin-bottom: 20px;
        border: 1px solid var(--glass-border);
        box-shadow: 0 0 25px rgba(230, 0, 0, 0.2);
    }
    header {
        text-align: center;
        padding: 20px;
    }
    h1 {
        font-size: 2.5em;
        margin-bottom: 10px;
        color: var(--f1-red);
        font-weight: 900;
        text-shadow: 0 0 10px var(--f1-red);
    }
    .controls {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        margin-bottom: 20px;
        padding: 15px;
        background: rgba(20, 20, 20, 0.7);
        border-radius: 10px;
        border: 1px solid rgba(230, 0, 0, 0.3);
    }
    .track-container,
    .info-panel {
        padding: 20px;
        max-height: 800px;
        overflow-y: auto;
    }
    .info-section {
        background: rgba(30, 30, 30, 0.7);
        backdrop-filter: blur(10px);
        padding: 15px;
        border-radius: 10px;
        margin-bottom: 15px;
        border: 1px solid rgba(230, 0, 0, 0.3);
    }
    .info-section h3 {
        color: var(--f1-red);
        margin-bottom: 10px;
        font-size: 1.1em;
        font-weight: 700;
        text-transform: uppercase;
    }
    button {
        padding: 12px 20px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 14px;
        color: var(--f1-white);
        background: rgba(230, 0, 0, 0.2);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        position: relative;
        overflow: hidden;
        font-family: 'Orbitron', sans-serif;
        text-transform: uppercase;
    }
    button::before {
        content: '';
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: radial-gradient(circle, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0) 70%);
        transition: transform 0.6s ease;
        transform: rotate(45deg) translate(-75%, -75%);
    }
    button:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 30px rgba(230, 0, 0, 0.5);
        background: rgba(230, 0, 0, 0.4);
    }
    button:hover::before {
        transform: rotate(45deg) translate(0, 0);
    }
    /* Differentiate buttons while maintaining theme */
    .btn-success { /* Start, Process */
        background: rgba(230, 0, 0, 0.3);
        box-shadow: 0 0 15px rgba(230, 0, 0, 0.5);
    }
    .btn-danger { /* Reset, Cancel */
        background: rgba(20, 20, 20, 0.6);
        border-color: rgba(255, 255, 255, 0.1);
    }
    .btn-danger:hover {
        background: rgba(40, 40, 40, 0.8);
        box-shadow: 0 8px 25px rgba(150, 150, 150, 0.3);
    }

    .telemetry-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        margin-top: 10px;
    }
    .telemetry-item {
        background: rgba(0, 0, 0, 0.3);
        padding: 10px;
        border-radius: 8px;
    }
    .telemetry-label {
        font-size: 0.85em;
        opacity: 0.7;
        margin-bottom: 5px;
        text-transform: uppercase;
    }
    .telemetry-value {
        font-size: 1.3em;
        font-weight: bold;
        color: var(--f1-white);
    }
    .progress-bar {
        width: 100%;
        height: 20px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        overflow: hidden;
        margin: 5px 0;
        border: 1px solid rgba(255,255,255,0.1);
    }
    .progress-fill {
        height: 100%;
        transition: width 0.3s;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.8em;
        font-weight: bold;
    }
    .fill-green { background: linear-gradient(90deg, #10b981, #047857); }
    .fill-yellow { background: linear-gradient(90deg, #f59e0b, #b45309); }
    .fill-red { background: linear-gradient(90deg, #ef4444, #b91c1c); }
    
    .event-log {
        background: rgba(0, 0, 0, 0.5);
        border-radius: 10px;
        border: 1px solid rgba(230,0,0,0.3);
        padding: 15px;
        max-height: 200px;
        overflow-y: auto;
        font-size: 0.9em;
        line-height: 1.6;
    }
    .event-log p {
        margin: 5px 0;
        padding: 5px;
        border-left: 3px solid var(--f1-red);
        padding-left: 10px;
    }
    .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        z-index: 1000;
        align-items: center;
        justify-content: center;
    }
    .modal-content {
        background: linear-gradient(135deg, #111, #222);
        padding: 30px;
        border-radius: 15px;
        border: 2px solid var(--f1-red);
        box-shadow: 0 0 40px rgba(230,0,0,0.5);
        max-width: 500px;
        width: 90%;
    }
    .modal-content h2 {
        color: var(--f1-red);
        margin-bottom: 20px;
    }
    .form-group {
        margin: 15px 0;
    }
    .form-group label {
        display: block;
        margin-bottom: 5px;
        font-size: 0.9em;
        opacity: 0.9;
    }
    .form-group input, .form-group select {
        width: 100%;
        padding: 10px;
        background: rgba(0, 0, 0, 0.3);
        border: 2px solid var(--glass-border);
        border-radius: 8px;
        color: white;
        font-size: 14px;
        font-family: 'Orbitron', sans-serif;
    }
    .prediction-box {
        background: rgba(230, 0, 0, 0.15);
        border: 2px solid var(--f1-red);
        border-radius: 10px;
        padding: 15px;
        margin: 10px 0;
    }
    .prediction-box h4 {
        color: var(--f1-red);
        margin-bottom: 10px;
    }
    @keyframes pulse {
        0%, 100% { box-shadow: 0 0 25px rgba(230, 0, 0, 0.2); }
        50% { box-shadow: 0 0 40px rgba(230, 0, 0, 0.6); }
    }
    .urgent {
        animation: pulse 1s infinite;
    }
    input[type="file"] {
        padding: 10px;
        background: rgba(230, 0, 0, 0.1);
        border: 2px dashed var(--f1-red);
        border-radius: 8px;
        cursor: pointer;
        width: 100%;
    }
    input[type="file"]::-webkit-file-upload-button {
        background: linear-gradient(135deg, var(--f1-red), var(--f1-red-dark));
        color: white;
        border: none;
        padding: 8px 15px;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        font-family: 'Orbitron', sans-serif;
    }
    .car-info {
        background: rgba(0, 0, 0, 0.4);
        padding: 10px;
        border-radius: 8px;
        margin: 8px 0;
        border-left: 4px solid;
    }
    .car-info.our-car {
        border-left-color: var(--f1-red);
        background: rgba(230, 0, 0, 0.1);
    }
    .car-info.ai-car {
        border-left-color: #3b82f6;
    }

    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üèéÔ∏è F1 Quantum Strategy Simulator</h1>
            <p>Real-Time AI Prediction Visualization with Python Backend Integration</p>
        </header>

        <div class="controls">
            <button class="btn-primary" onclick="showTrackUploadModal()">üìÅ Upload Track</button>
            <button class="btn-success" onclick="startRace()" id="startBtn">‚ñ∂Ô∏è Start Race</button>
            <button class="btn-warning" onclick="pauseRace()" id="pauseBtn">‚è∏Ô∏è Pause</button>
            <button class="btn-danger" onclick="resetRace()">üîÑ Reset</button>
            <button class="btn-primary" onclick="analyzeStrategy()">üß† Analyze Strategy</button>
            <button class="btn-primary" onclick="showConfigModal()">‚öôÔ∏è Settings</button>
            
        </div>

        <div class="main-grid">
            <div class="track-container">
                <canvas id="trackCanvas" width="1000" height="700"></canvas>
            </div>

            <div class="info-panel">
                <div class="info-section">
                    <h3>üìä Race Status</h3>
                    <div id="opencvStatus" style="padding: 8px; background: rgba(251, 146, 60, 0.2); border-radius: 5px; margin-bottom: 10px; font-size: 0.85em;">
                        ‚≥†Backend: Checking...
                    </div>
                    <div class="telemetry-grid">
                        <div class="telemetry-item">
                            <div class="telemetry-label">Current Lap</div>
                            <div class="telemetry-value" id="currentLap">1/50</div>
                        </div>
                        <div class="telemetry-item">
                            <div class="telemetry-label">Position</div>
                            <div class="telemetry-value" id="position">P5</div>
                        </div>
                        <div class="telemetry-item">
                            <div class="telemetry-label">Lap Time</div>
                            <div class="telemetry-value" id="lapTime">1:28.234</div>
                        </div>
                        <div class="telemetry-item">
                            <div class="telemetry-label">Total Time</div>
                            <div class="telemetry-value" id="totalTime">0:00.000</div>
                        </div>
                    </div>
                </div>

                <div class="info-section">
                    <h3>üõû Telemetry</h3>
                    <div>
                        <div class="telemetry-label">Tyre Wear</div>
                        <div class="progress-bar">
                            <div class="progress-fill fill-green" id="tyreWearBar" style="width: 35%">35%</div>
                        </div>
                    </div>
                    <div>
                        <div class="telemetry-label">Fuel Load</div>
                        <div class="progress-bar">
                            <div class="progress-fill fill-green" id="fuelBar" style="width: 85%">85%</div>
                        </div>
                    </div>
                    <div class="telemetry-grid" style="margin-top: 10px;">
                        <div class="telemetry-item">
                            <div class="telemetry-label">FL Temp</div>
                            <div class="telemetry-value" id="tempFL">95¬∞C</div>
                        </div>
                        <div class="telemetry-item">
                            <div class="telemetry-label">FR Temp</div>
                            <div class="telemetry-value" id="tempFR">96¬∞C</div>
                        </div>
                        <div class="telemetry-item">
                            <div class="telemetry-label">RL Temp</div>
                            <div class="telemetry-value" id="tempRL">94¬∞C</div>
                        </div>
                        <div class="telemetry-item">
                            <div class="telemetry-label">RR Temp</div>
                            <div class="telemetry-value" id="tempRR">95¬∞C</div>
                        </div>
                    </div>
                </div>

                <div class="info-section" id="aiRecommendation">
                    <h3>ü§ñ AI Recommendation</h3>
                    <p style="opacity: 0.7;">Click "Analyze Strategy" to get AI recommendations</p>
                </div>

                <div class="info-section" id="predictionBox" style="display: none;">
                    <h3>üîÆ Prediction</h3>
                    <div id="predictionContent"></div>
                </div>

                <div class="info-section">
                    <h3>üèÅ Competitors</h3>
                    <div id="competitorsList"></div>
                </div>
            </div>
        </div>

        <div class="event-log" id="eventLog">
            <p>üèéÔ∏è System initialized - Upload a track to begin</p>
        </div>
    </div>

    <div id="trackUploadModal" class="modal">
        <div class="modal-content">
            <h2>üìÅ Upload Track Layout</h2>
            <div class="form-group">
                <label>Track Image (PNG/JPG)</label>
                <input type="file" id="trackImageInput" accept="image/*">
            </div>
            <div class="form-group">
                <label>Track Name</label>
                <input type="text" id="trackNameInput" placeholder="e.g., Monaco, Silverstone">
            </div>
            <div class="form-group">
                <label>Total Laps</label>
                <input type="number" id="totalLapsInput" value="50" min="10" max="100">
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-success" style="flex: 1;" onclick="processTrackUpload()">‚úÖ Process Track</button>
                <button class="btn-danger" style="flex: 1;" onclick="closeModal('trackUploadModal')">‚ùå Cancel</button>
            </div>
        </div>
    </div>

    <div id="configModal" class="modal">
        <div class="modal-content">
            <h2>‚öôÔ∏è Settings</h2>
            <div class="form-group">
                <label>Track Processing Backend URL</label>
                <input type="text" id="apiUrlInput" value="http://localhost:8001">
            </div>
            <div class="form-group">
                <label>AI Prediction System URL</label>
                <input type="text" id="aiUrlInput" value="http://localhost:8080">
            </div>
            <div class="form-group">
                <label>Starting Position</label>
                <input type="number" id="startPositionInput" value="5" min="1" max="20">
            </div>
            <div class="form-group">
                <label>Number of Competitors</label>
                <input type="number" id="numCompetitorsInput" value="4" min="1" max="19">
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-success" style="flex: 1;" onclick="saveConfig()">‚úÖ Save</button>
                <button class="btn-danger" style="flex: 1;" onclick="closeModal('configModal')">‚ùå Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== GLOBAL STATE ====================
        let API_URL = 'http://localhost:8001';  // Track processing backend
        let AI_URL = 'http://localhost:8000';    // AI prediction system
        let canvas = document.getElementById('trackCanvas');
        let ctx = canvas.getContext('2d');
        
        let raceState = {
            isRunning: false,
            isPaused: false,
            currentLap: 1,
            totalLaps: 50,
            trackLoaded: false
        };

        let trackData = {
            name: 'Default Track',
            points: [],
            polygons: [],
            startLine: null,
            drsZones: []
        };

        let ourCar = {
            id: 'car_our',
            position: 5,
            progress: 0,
            speed: 290,
            tyreWear: 0,
            tyreTemp: {FL: 95, FR: 95, RL: 95, RR: 95},
            fuel: 110,
            lapTime: 0,
            currentLap: 1,
            paceMode: 'BALANCED',
            x: 0,
            y: 0,
            angle: 0,
            totalTime: 0,
            actionInProgress: null
        };

        let competitors = [];
        let lastTime = Date.now();
        let animationFrame = null;
        let currentStrategyResponse = null;
        let telemetryHistory = [];

        // ==================== TRACK PROCESSING ====================
        function showTrackUploadModal() {
            document.getElementById('trackUploadModal').style.display = 'flex';
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        async function processTrackUpload() {
            const fileInput = document.getElementById('trackImageInput');
            const trackName = document.getElementById('trackNameInput').value || 'Custom Track';
            const totalLaps = parseInt(document.getElementById('totalLapsInput').value) || 50;

            if (!fileInput.files || fileInput.files.length === 0) {
                alert('Please select a track image');
                return;
            }

            const file = fileInput.files[0];
            logEvent(`üîç Processing track: ${trackName}...`);
            logEvent(`üêç Using Python backend for accurate polygon extraction...`);

            try {
                const formData = new FormData();
                formData.append('file', file);
                formData.append('epsilon', '0.01');

                const response = await fetch(`${API_URL}/api/analyze`, {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error(`Backend returned ${response.status}`);
                }

                const result = await response.json();
                const trackAnalysis = result.data;

                logEvent(`‚úÖ Backend processing complete!`);
                logEvent(`üìä Detected ${trackAnalysis.statistics.num_segments} segments`);
                logEvent(`üìè Total track length: ${trackAnalysis.statistics.total_length.toFixed(0)}px`);

                const polygons = [];
                trackAnalysis.segments.forEach(seg => {
                    if (seg.start) {
                        polygons.push({x: seg.start[0], y: seg.start[1]});
                    }
                });
                
                if (polygons.length > 0) {
                    const first = polygons[0];
                    const last = polygons[polygons.length - 1];
                    if (Math.abs(first.x - last.x) > 5 || Math.abs(first.y - last.y) > 5) {
                        polygons.push({x: first.x, y: first.y});
                    }
                }

                if (polygons.length < 3) {
                    alert('Backend did not return enough polygon points. Try a different image.');
                    return;
                }

                trackData.name = trackName;
                trackData.points = polygons;
                trackData.polygons = polygons;
                trackData.startLine = {x: polygons[0].x, y: polygons[0].y};
                trackData.drsZones = generateDRSZones(polygons);
                
                raceState.totalLaps = totalLaps;
                raceState.trackLoaded = true;

                scaleTrackToCanvas();
                
                logEvent(`‚úÖ Track loaded: ${trackName} (${polygons.length} segments)`);
                closeModal('trackUploadModal');
                
                drawTrack();

            } catch (error) {
                console.error('Backend track processing error:', error);
                logEvent(`‚ö†Ô∏è Backend failed: ${error.message}`);
                alert('Could not connect to Python backend. Make sure it\'s running on ' + API_URL);
            }
        }

        function scaleTrackToCanvas() {
            if (trackData.polygons.length === 0) return;

            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;

            trackData.polygons.forEach(p => {
                minX = Math.min(minX, p.x);
                minY = Math.min(minY, p.y);
                maxX = Math.max(maxX, p.x);
                maxY = Math.max(maxY, p.y);
            });

            const trackWidth = maxX - minX;
            const trackHeight = maxY - minY;
            const padding = 50;

            const scaleX = (canvas.width - padding * 2) / trackWidth;
            const scaleY = (canvas.height - padding * 2) / trackHeight;
            const scale = Math.min(scaleX, scaleY);

            trackData.polygons = trackData.polygons.map(p => ({
                x: (p.x - minX) * scale + padding,
                y: (p.y - minY) * scale + padding
            }));

            trackData.startLine = {
                x: trackData.polygons[0].x,
                y: trackData.polygons[0].y
            };
        }

        function generateDRSZones(polygons) {
            const zones = [];
            const totalPoints = polygons.length;

            zones.push({
                start: Math.floor(totalPoints * 0.2),
                end: Math.floor(totalPoints * 0.4),
                name: 'DRS Zone 1'
            });

            zones.push({
                start: Math.floor(totalPoints * 0.6),
                end: Math.floor(totalPoints * 0.8),
                name: 'DRS Zone 2'
            });

            return zones;
        }

        function distance(p1, p2) {
            return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
        }

        // ==================== TRACK RENDERING ====================
        function drawTrack() {
            // Pure black background
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (!raceState.trackLoaded || trackData.polygons.length < 2) {
                ctx.fillStyle = '#ffffff';
                ctx.font = '24px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText('Upload a track to begin', canvas.width / 2, canvas.height / 2);
                return;
            }

            // Black asphalt
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Track outline (wide, smooth)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 60;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            trackData.polygons.forEach((p, i) => {
                if (i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            });
            ctx.stroke();

            // Clean white racing line
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            ctx.stroke();

            // DRS Zones (subtle red pulse)
            trackData.drsZones.forEach(zone => {
                ctx.strokeStyle = 'rgba(230, 0, 0, 0.3)';
                ctx.lineWidth = 40;
                ctx.setLineDash([12, 8]);
                ctx.beginPath();
                for (let i = zone.start; i <= zone.end && i < trackData.polygons.length; i++) {
                    const p = trackData.polygons[i];
                    if (i === zone.start) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                }
                ctx.stroke();
                ctx.setLineDash([]);
            });

            // Checkered flag start/finish line
            if (trackData.startLine) {
                const start = trackData.startLine;
                const size = 8;
                ctx.fillStyle = '#ffffff';
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 8; col++) {
                        const isBlack = (row + col) % 2 === 0;
                        ctx.fillStyle = isBlack ? '#000000' : '#ffffff';
                        ctx.fillRect(
                            start.x - 20 + col * size,
                            start.y - 16 + row * size,
                            size, size
                        );
                    }
                }
            }

            // Draw cars
            drawCar(ourCar, true);
            competitors.forEach(car => drawCar(car, false));
        }
        function drawCar(car, isOurCar) {
            ctx.save();
            ctx.translate(car.x, car.y);
            ctx.rotate(car.angle);

            // Car base
            if (isOurCar) {
                ctx.fillStyle = '#e60000'; // F1 red
                ctx.shadowColor = '#e60000';
                ctx.shadowBlur = car.actionInProgress ? 25 : 15;
            } else {
                // Different colors for competitors
                const competitorColors = ['#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899'];
                const colorIndex = parseInt(car.id.split('_')[1]) % competitorColors.length;
                ctx.fillStyle = competitorColors[colorIndex];
                ctx.shadowColor = car.actionInProgress ? '#fbbf24' : '#333';
                ctx.shadowBlur = car.actionInProgress ? 20 : 8;
            }

            // F1 nose shape
            ctx.beginPath();
            ctx.moveTo(-10, -15);
            ctx.lineTo(0, -25);
            ctx.lineTo(10, -15);
            ctx.lineTo(8, 15);
            ctx.lineTo(-8, 15);
            ctx.closePath();
            ctx.fill();

            // Gloss highlight
            ctx.fillStyle = isOurCar ? 'rgba(255, 220, 220, 0.4)' : 'rgba(255, 255, 255, 0.2)';
            ctx.beginPath();
            ctx.moveTo(-8, -12);
            ctx.lineTo(0, -20);
            ctx.lineTo(8, -12);
            ctx.lineTo(6, -5);
            ctx.lineTo(-6, -5);
            ctx.closePath();
            ctx.fill();

            // Action glow
            if (car.actionInProgress) {
                const glowColor = car.actionInProgress.type === 'OVERTAKE' ? '#fb923c' : '#eab308';
                ctx.shadowColor = glowColor;
                ctx.shadowBlur = 25;
                const pulse = 1 + Math.sin(Date.now() / 150) * 0.15;
                ctx.scale(pulse, pulse);
            }

            // Position label
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 14px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`P${car.position}`, 0, 2);

            // Action icon
            if (car.actionInProgress) {
                ctx.font = 'bold 18px Arial'; // Arial is better for emoji support
                const icon = car.actionInProgress.type === 'OVERTAKE' ? 'üèÅ' : 'üîß';
                ctx.fillText(icon, 0, -28);
            }

            ctx.restore();
        }

        // ==================== CAR MOVEMENT ====================
       function updateCarPosition(car, deltaTime) {
    if (!raceState.trackLoaded || trackData.polygons.length < 2) return;

    const speed = getCarSpeed(car);
    const progressIncrement = (speed / 290) * 0.0008 * deltaTime;
    car.progress += progressIncrement;

    if (car.progress >= 1.0) {
        car.progress -= 1.0;
        car.currentLap++;
        if (car.id === 'car_our') {
            onLapComplete();
        } else {
            // Competitor lap complete
            onCompetitorLapComplete(car);
        }
    }

    const totalPoints = trackData.polygons.length;
    const exactIdx = car.progress * (totalPoints - 1);
    const idx = Math.floor(exactIdx);
    const nextIdx = Math.min(idx + 1, totalPoints - 1);
    
    const p1 = trackData.polygons[idx];
    const p2 = trackData.polygons[nextIdx];
    const t = exactIdx - idx;

    car.x = p1.x + (p2.x - p1.x) * t;
    car.y = p1.y + (p2.y - p1.y) * t;
    car.angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
}
function onCompetitorLapComplete(car) {
    car.lapTime = 88 + Math.random() * 3 + (car.tyreWear / 50);
    
    // AI Pit stop decision logic
    const shouldPit = shouldCompetitorPit(car);
    
    if (shouldPit) {
        executeCompetitorPitStop(car);
    }
    
    logEvent(`üèÅ ${car.id} Lap ${car.currentLap} complete - ${car.lapTime.toFixed(3)}s (Wear: ${car.tyreWear.toFixed(1)}%)`);
}
function shouldCompetitorPit(car) {
    // Pit stop decision logic for AI competitors
    
    // Critical conditions - must pit
    if (car.tyreWear > 85) {
        return true;
    }
    
    // High wear + long stint - should pit
    if (car.tyreWear > 70 && car.tyreAge > 20) {
        return true;
    }
    
    // Strategic pit window (lap 15-35 for 50 lap race)
    if (car.currentLap >= 15 && car.currentLap <= 35) {
        // Pit with some randomness to simulate different strategies
        if (car.tyreWear > 60) {
            // 30% chance to pit each lap when wear is high
            return Math.random() < 0.3;
        }
        
        if (car.tyreWear > 50 && car.tyreAge > 18) {
            // 20% chance with moderate wear
            return Math.random() < 0.2;
        }
    }
    
    // Low fuel emergency
    if (car.fuel < 10) {
        return true;
    }
    
    return false;
}

function executeCompetitorPitStop(car) {
    logEvent(`üîß ${car.id} entering pit lane (Wear: ${car.tyreWear.toFixed(1)}%, Lap: ${car.currentLap})`);
    
    car.actionInProgress = {
        type: 'PIT_STOP',
        startTime: Date.now(),
        startLap: car.currentLap
    };
    
    // Simulate pit stop time (20-24 seconds)
    const pitTime = 20 + Math.random() * 4;
    
    setTimeout(() => {
        // Reset tyre condition
        car.tyreWear = 0;
        car.tyreAge = 0;
        car.tyreTemp = {FL: 95, FR: 95, RL: 95, RR: 95};
        
        // Refuel
        car.fuel = 110;
        
        // Lose some track position
        const oldPos = car.position;
        const positionsLost = Math.floor(pitTime / 22 * 2);
        car.position = Math.min(20, car.position + positionsLost);
        
        // Lose some progress on track
        car.progress = Math.max(0, car.progress - 0.03);
        
        car.actionInProgress = null;
        
        logEvent(`‚úÖ ${car.id} pit complete - Fresh tyres! P${oldPos} ‚Üí P${car.position}`);
        
    }, pitTime * 100); // Scaled time for simulation
}
        function getCarSpeed(car) {
    let speed = 290;
    
    if (car.id === 'car_our') {
        speed -= (car.tyreWear / 100) * 30;
        speed += ((110 - car.fuel) / 110) * 5;
        
        if (car.paceMode === 'ATTACK') speed *= 1.05;
        else if (car.paceMode === 'PUSH') speed *= 1.03;
        else if (car.paceMode === 'CONSERVE') speed *= 0.97;
        
        const avgTemp = (car.tyreTemp.FL + car.tyreTemp.FR + car.tyreTemp.RL + car.tyreTemp.RR) / 4;
        if (avgTemp > 110) speed *= 0.98;
        if (avgTemp > 115) speed *= 0.95;
    } else {
        // Competitor speed calculation
        speed = 288 + Math.sin(Date.now() / 1000 + car.position) * 2;
        
        // Tyre wear effect
        speed -= (car.tyreWear / 100) * 25;
        
        // Fuel effect (lighter = faster)
        speed += ((110 - car.fuel) / 110) * 4;
        
        // Temperature effect
        const avgTemp = (car.tyreTemp.FL + car.tyreTemp.FR + car.tyreTemp.RL + car.tyreTemp.RR) / 4;
        if (avgTemp > 110) speed *= 0.98;
        if (avgTemp > 115) speed *= 0.94;
        
        // Pit stop penalty (car is slower in pit lane)
        if (car.actionInProgress && car.actionInProgress.type === 'PIT_STOP') {
            speed *= 0.3; // 30% speed in pit
        }
    }
    
    car.speed = speed;
    return speed;
}


        function updateTelemetry(car, deltaTime) {
    // Skip telemetry update if car is pitting
    if (car.actionInProgress && car.actionInProgress.type === 'PIT_STOP') {
        return;
    }
    
    if (car.id !== 'car_our') {
        // Competitor telemetry
        let wearRate = 0.025; // Base wear rate
        
        // Increase wear rate if pushing hard
        const avgTemp = (car.tyreTemp.FL + car.tyreTemp.FR + car.tyreTemp.RL + car.tyreTemp.RR) / 4;
        if (avgTemp > 105) {
            wearRate *= 1.3;
        }
        
        car.tyreWear += wearRate * deltaTime;
        car.tyreWear = Math.min(100, car.tyreWear);
        car.tyreAge++;
        
        car.fuel -= 0.02 * deltaTime;
        car.fuel = Math.max(0, car.fuel);
        
        // Temperature simulation
        const baseTemp = 95;
        const wearTemp = car.tyreWear / 8;
        const targetTemp = baseTemp + wearTemp;
        
        ['FL', 'FR', 'RL', 'RR'].forEach(pos => {
            const diff = targetTemp - car.tyreTemp[pos];
            car.tyreTemp[pos] += diff * 0.05 * deltaTime;
        });
        
        return;
    }

    // Our car telemetry (existing code)
    let wearRate = 0.04;
    if (car.paceMode === 'ATTACK') wearRate *= 1.5;
    else if (car.paceMode === 'PUSH') wearRate *= 1.3;
    else if (car.paceMode === 'CONSERVE') wearRate *= 0.8;
    
    car.tyreWear += wearRate * deltaTime;
    car.tyreWear = Math.min(100, car.tyreWear);
    
    let fuelRate = 0.025;
    if (car.paceMode === 'ATTACK') fuelRate *= 1.2;
    car.fuel -= fuelRate * deltaTime;
    car.fuel = Math.max(0, car.fuel);
    
    const baseTemp = 95;
    const wearTemp = car.tyreWear / 8;
    const paceTemp = car.paceMode === 'ATTACK' ? 8 : car.paceMode === 'PUSH' ? 5 : 0;
    const targetTemp = baseTemp + wearTemp + paceTemp;
    
    ['FL', 'FR', 'RL', 'RR'].forEach(pos => {
        const diff = targetTemp - car.tyreTemp[pos];
        car.tyreTemp[pos] += diff * 0.08 * deltaTime;
    });
}
        // ==================== RACE CONTROL ====================
        function startRace() {
            if (!raceState.trackLoaded) {
                alert('Please upload a track first!');
                return;
            }

            if (!raceState.isRunning) {
                raceState.isRunning = true;
                raceState.isPaused = false;
                lastTime = Date.now();
                logEvent('üö¶ Lights out and away we go!');
                updateLoop();
            }
        }

        function pauseRace() {
            raceState.isPaused = !raceState.isPaused;
            logEvent(raceState.isPaused ? '‚è∏Ô∏è Race paused' : '‚ñ∂Ô∏è Race resumed');
            if (!raceState.isPaused && raceState.isRunning) {
                lastTime = Date.now();
                updateLoop();
            }
        }

        function resetRace() {
    raceState.isRunning = false;
    raceState.isPaused = false;
    raceState.currentLap = 1;
    
    if (animationFrame) cancelAnimationFrame(animationFrame);
    
    ourCar.progress = 0;
    ourCar.tyreWear = 0;
    ourCar.fuel = 110;
    ourCar.currentLap = 1;
    ourCar.paceMode = 'BALANCED';
    ourCar.tyreTemp = {FL: 95, FR: 95, RL: 95, RR: 95};
    ourCar.totalTime = 0;
    ourCar.actionInProgress = null;
    ourCar.tyreAge = 0;
    
    initCompetitors();
    
    telemetryHistory = [];
    currentStrategyResponse = null;
    
    updateUI();
    drawTrack();
    logEvent('üîÑ Race reset complete');
}
function createCompetitor(id) {
    return {
        id: `car_${id}`,
        position: id < ourCar.position ? id : id + 1,
        progress: Math.random() * 0.1,
        speed: 288 + Math.random() * 4,
        tyreWear: Math.random() * 10,
        tyreTemp: {FL: 95, FR: 95, RL: 95, RR: 95},
        fuel: 110,
        lapTime: 0,
        currentLap: 1,
        paceMode: 'BALANCED',
        x: 0,
        y: 0,
        angle: 0,
        tyreAge: 0,
        actionInProgress: null
    };
}function initCompetitors() {
    competitors = [];
    const numComps = parseInt(document.getElementById('numCompetitorsInput')?.value || 4);
    for (let i = 1; i <= numComps; i++) {
        competitors.push(createCompetitor(i));
    }
}

        function updateLoop() {
            if (!raceState.isRunning || raceState.isPaused) return;
            
            const now = Date.now();
            const deltaTime = Math.min((now - lastTime) / 16.67, 2);
            lastTime = now;
            
            updateCarPosition(ourCar, deltaTime);
            updateTelemetry(ourCar, deltaTime);
            
            competitors.forEach(car => {
                updateCarPosition(car, deltaTime);
                updateTelemetry(car, deltaTime);
            });
            
            updateRacePositions();
            
            updateUI();
            drawTrack();
            
            if (ourCar.currentLap <= raceState.totalLaps) {
                animationFrame = requestAnimationFrame(updateLoop);
            } else {
                endRace();
            }
        }

        function updateRacePositions() {
            const allCars = [ourCar, ...competitors];
            allCars.sort((a, b) => {
                if (a.currentLap !== b.currentLap) return b.currentLap - a.currentLap;
                return b.progress - a.progress;
            });
            
            allCars.forEach((car, idx) => {
                car.position = idx + 1;
            });
        }

        function onLapComplete() {
            ourCar.lapTime = 88 + Math.random() * 3 + (ourCar.tyreWear / 50);
            ourCar.totalTime += ourCar.lapTime;
            raceState.currentLap = ourCar.currentLap;
            
            logEvent(`üèÅ Lap ${ourCar.currentLap} complete - ${ourCar.lapTime.toFixed(3)}s`);
            
            telemetryHistory.push({
                current_lap: ourCar.currentLap,
                tyre_wear: ourCar.tyreWear,
                fuel_load: ourCar.fuel,
                tyre_temp: {...ourCar.tyreTemp},
                lap_time: ourCar.lapTime,
                position: ourCar.position,
                sector_times: [28.5, 31.8, 28.2],
                speed: ourCar.speed
            });
            
            if (telemetryHistory.length > 50) {
                telemetryHistory = telemetryHistory.slice(-50);
            }
            
            if (ourCar.currentLap % 5 === 0) {
                setTimeout(() => analyzeStrategy(), 1000);
            }
        }

        function endRace() {
            raceState.isRunning = false;
            logEvent(`üèÜ RACE FINISHED! Final Position: P${ourCar.position}`);
            
            document.getElementById('aiRecommendation').innerHTML = `
                <h3>üèÅ Race Complete!</h3>
                <div style="text-align: center; padding: 20px;">
                    <div style="font-size: 48px; font-weight: bold; color: #22c55e;">P${ourCar.position}</div>
                    <p style="margin-top: 10px;">Final Position</p>
                    <p style="margin-top: 10px;">Total Time: ${formatTime(ourCar.totalTime)}</p>
                    <button class="btn-primary" onclick="resetRace()" style="margin-top: 15px;">üîÑ New Race</button>
                </div>
            `;
        }

        // ==================== BACKEND INTEGRATION ====================
        async function analyzeStrategy() {
            if (!raceState.trackLoaded) {
                alert('Please start a race first!');
                return;
            }

            logEvent('üß† Analyzing strategy with AI backend...');

            // Format data exactly as the AI backend expects (from main.py OurCarData model)
            const raceData = {
                timestamp: Date.now(),
                our_car: {
                    position: ourCar.position,
                    speed: ourCar.speed,
                    tyre_temp: {
                        FL: Math.round(ourCar.tyreTemp.FL),
                        FR: Math.round(ourCar.tyreTemp.FR),
                        RL: Math.round(ourCar.tyreTemp.RL),
                        RR: Math.round(ourCar.tyreTemp.RR)
                    },
                    tyre_wear: ourCar.tyreWear,
                    fuel_load: ourCar.fuel,
                    lap_time: ourCar.lapTime,
                    current_lap: ourCar.currentLap,
                    sector_times: [28.5, 31.8, 28.2], // Default sector times
                    slow_sectors: [] // Can be populated based on sector performance
                },
                competitors: competitors.map(c => ({
                    car_id: c.id,
                    position: c.position,
                    speed: Math.round(c.speed),
                    gap: Math.abs(c.position - ourCar.position) * 2.5,
                    slow_zones: [], // Empty for now
                    tyre_age: Math.floor(c.tyreWear / 3) // Estimate age from wear
                })),
                track_conditions: {
                    temperature: 28,
                    rainfall: 0,
                    track_evolution: 85
                },
                total_laps: raceState.totalLaps,
                drs_zones: trackData.drsZones.map(z => z.name)
            };

            try {
                const response = await fetch(`${AI_URL}/api/strategy/analyze`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(raceData)
                });

                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const result = await response.json();
                currentStrategyResponse = result;

                displayStrategyResults(result);
                executeRecommendedAction(result);

                logEvent(`‚úÖ AI Analysis complete - ${result.response_time_ms || 0}ms`);

            } catch (error) {
                console.error('AI Backend error:', error);
                logEvent(`‚ö†Ô∏è AI Backend connection failed: ${error.message}`);
                alert('Could not connect to AI backend. Make sure it\'s running on ' + AI_URL);
            }
        }

        function displayStrategyResults(result) {
            const action = result.immediate_action;
            const pit = result.pit_stop_recommendation;
            const pace = result.pace_strategy;
            const overtakes = result.overtaking_opportunities || [];

            let priorityColor = '#22c55e';
            if (action.priority === 'CRITICAL') priorityColor = '#ef4444';
            else if (action.priority === 'HIGH') priorityColor = '#f97316';
            else if (action.priority === 'MEDIUM') priorityColor = '#eab308';

            document.getElementById('aiRecommendation').innerHTML = `
                <h3>ü§ñ AI Recommendation</h3>
                <div style="background: rgba(139, 92, 246, 0.2); padding: 15px; border-radius: 8px; border: 2px solid ${priorityColor}; ${action.priority === 'CRITICAL' ? 'animation: pulse 1.5s infinite;' : ''}">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <strong style="font-size: 1.1em;">${formatActionName(action.action)}</strong>
                        <span style="background: ${priorityColor}; padding: 4px 12px; border-radius: 12px; font-size: 0.85em;">${action.priority}</span>
                    </div>
                    <p style="font-size: 0.9em; opacity: 0.9; margin: 8px 0;">${action.reasoning}</p>
                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <div style="flex: 1; background: rgba(0,0,0,0.3); padding: 8px; border-radius: 5px; text-align: center;">
                            <div style="font-size: 0.8em; opacity: 0.7;">Confidence</div>
                            <div style="font-size: 1.2em; font-weight: bold; color: ${action.confidence >= 70 ? '#22c55e' : '#ef4444'};">${action.confidence}%</div>
                        </div>
                        <div style="flex: 1; background: rgba(0,0,0,0.3); padding: 8px; border-radius: 5px; text-align: center;">
                            <div style="font-size: 0.8em; opacity: 0.7;">Status</div>
                            <div style="font-size: 1.2em; font-weight: bold;">${action.confidence >= 70 ? '‚úÖ EXECUTING' : '‚ö†Ô∏è SKIPPED'}</div>
                        </div>
                    </div>
                </div>

                <div style="margin-top: 15px; padding: 12px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                    <strong style="font-size: 0.95em;">üîß Pit Strategy</strong>
                    <p style="font-size: 0.85em; margin: 5px 0;">${pit.recommendation}</p>
                    <div style="font-size: 0.8em; opacity: 0.8;">
                        Lap ${pit.optimal_lap} ‚Ä¢ ${pit.tyre_compound} ‚Ä¢ ${pit.confidence}% confidence
                    </div>
                </div>

                <div style="margin-top: 10px; padding: 12px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                    <strong style="font-size: 0.95em;">‚ö° Pace Mode</strong>
                    <p style="font-size: 0.85em; margin: 5px 0;">${pace.pace_mode}: ${pace.lap_time_target}</p>
                </div>

                ${overtakes.length > 0 ? `
                <div style="margin-top: 10px; padding: 12px; background: rgba(34, 197, 94, 0.1); border-radius: 8px; border-left: 3px solid #22c55e;">
                    <strong style="font-size: 0.95em;">üèÅ Overtake Opportunity</strong>
                    <p style="font-size: 0.85em; margin: 5px 0;">Target P${overtakes[0].current_position} - ${overtakes[0].probability}% success</p>
                    <p style="font-size: 0.8em; opacity: 0.8;">${overtakes[0].recommendation}</p>
                </div>
                ` : ''}
            `;
        }

        function formatActionName(action) {
            const icons = {
                'OVERTAKE': 'üèÅ',
                'PIT_NOW': 'üîß',
                'PIT_SOON': '‚è∞',
                'HOLD_POSITION': 'üõ°Ô∏è',
                'PUSH_PACE': '‚ö°',
                'DEFEND': 'üöß',
                'CONSERVE': 'üê¢'
            };
            return `${icons[action] || 'üìç'} ${action.replace(/_/g, ' ')}`;
        }

        function executeRecommendedAction(result) {
            const action = result.immediate_action.action;
            const confidence = result.immediate_action.confidence;

            if (confidence < 70) {
                logEvent(`‚ö†Ô∏è AI action not executed - confidence ${confidence}% < 70% threshold`);
                return;
            }

            logEvent(`üéØ AI executing ${action} with ${confidence}% confidence`);

            if (action === 'PIT_NOW' || action === 'PIT_SOON') {
                setTimeout(() => executePitStop(), 2000);
            } else if (action === 'OVERTAKE') {
                setTimeout(() => executeOvertake(result.overtaking_opportunities), 1000);
            } else if (action === 'PUSH_PACE') {
                ourCar.paceMode = 'PUSH';
                logEvent('‚ö° Activated PUSH mode - AI strategy');
            } else if (action === 'CONSERVE') {
                ourCar.paceMode = 'CONSERVE';
                logEvent('üê¢ Activated CONSERVE mode - AI strategy');
            } else if (action === 'HOLD_POSITION') {
                ourCar.paceMode = 'BALANCED';
                logEvent('üõ°Ô∏è Holding position - AI strategy');
            }
        }

        function executePitStop() {
            if (!currentStrategyResponse) return;

            logEvent('üîß Executing AI-recommended pit stop...');
            
            const pit = currentStrategyResponse.pit_stop_recommendation;
            
            ourCar.actionInProgress = {
                type: 'PIT_STOP',
                startTime: Date.now()
            };
            
            const pitTime = 21 + Math.random() * 3;
            const expectedImpact = pit.expected_time_impact || 0;
            
            showPitStopAnimation(pitTime);
            
            setTimeout(() => {
                ourCar.tyreWear = 0;
                ourCar.tyreTemp = {FL: 95, FR: 95, RL: 95, RR: 95};
                
                const oldPos = ourCar.position;
                const positionsLost = Math.floor(pitTime / 22 * 2);
                ourCar.position = Math.min(20, ourCar.position + positionsLost);
                
                ourCar.progress = Math.max(0, ourCar.progress - 0.03);
                
                ourCar.totalTime += pitTime;
                
                ourCar.actionInProgress = null;

                logEvent(`‚úÖ Pit complete - ${pit.tyre_compound} tyres fitted`);
                logEvent(`   Position change: P${oldPos} ‚Üí P${ourCar.position}`);
                logEvent(`   ‚è±Ô∏è Pit time: +${pitTime.toFixed(1)}s`);
                logEvent(`   üìä Expected long-term impact: ${expectedImpact.toFixed(1)}s`);
                
                showTimeEffect(pitTime);
            }, pitTime * 100);
        }

        function showPitStopAnimation(pitTime) {
            const indicator = document.createElement('div');
            indicator.style.position = 'fixed';
            indicator.style.top = '50%';
            indicator.style.left = '50%';
            indicator.style.transform = 'translate(-50%, -50%)';
            indicator.style.background = 'rgba(234, 179, 8, 0.95)';
            indicator.style.padding = '20px 30px';
            indicator.style.borderRadius = '15px';
            indicator.style.border = '3px solid #eab308';
            indicator.style.fontSize = '24px';
            indicator.style.fontWeight = 'bold';
            indicator.style.color = '#fff';
            indicator.style.zIndex = '10000';
            indicator.style.boxShadow = '0 10px 40px rgba(234, 179, 8, 0.5)';
            indicator.innerHTML = `üîß PIT STOP IN PROGRESS<br><span style="font-size: 18px;">Expected: ${pitTime.toFixed(1)}s</span>`;
            document.body.appendChild(indicator);
            
            setTimeout(() => {
                indicator.remove();
            }, pitTime * 100);
        }

        function executeOvertake(opportunities) {
            if (!opportunities || opportunities.length === 0) return;

            const opp = opportunities[0];
            const probability = opp.probability;

            ourCar.actionInProgress = {
                type: 'OVERTAKE',
                target: opp.current_position,
                startTime: Date.now()
            };

            logEvent(`üèÅ AI executing overtake on P${opp.current_position}...`);
            logEvent(`   Success probability: ${probability}%`);
            
            showOvertakeAnimation(opp.current_position);

            const roll = Math.random() * 100;
            
            setTimeout(() => {
                ourCar.actionInProgress = null;
                
                if (roll < probability) {
                    const oldPos = ourCar.position;
                    const timeGain = 0.3 + Math.random() * 0.5;
                    
                    const targetCar = competitors.find(c => c.position === opp.current_position);
                    if (targetCar) {
                        ourCar.position = targetCar.position;
                        targetCar.position = oldPos;
                        ourCar.progress += 0.015;
                        
                        ourCar.totalTime -= timeGain;
                    } else {
                        ourCar.position = Math.max(1, ourCar.position - 1);
                        ourCar.progress += 0.015;
                        ourCar.totalTime -= timeGain;
                    }
                    
                    logEvent(`‚úÖ Overtake successful! P${oldPos} ‚Üí P${ourCar.position}`);
                    logEvent(`   ‚è±Ô∏è Time gained: -${timeGain.toFixed(3)}s`);
                    logEvent(`   üéØ AI prediction was correct!`);
                    
                    showTimeEffect(-timeGain);
                } else {
                    const timeLoss = 0.2 + Math.random() * 0.4;
                    ourCar.progress -= 0.008;
                    ourCar.totalTime += timeLoss;
                    
                    logEvent(`‚ùå Overtake failed - lost time`);
                    logEvent(`   ‚è±Ô∏è Time lost: +${timeLoss.toFixed(3)}s`);
                    logEvent(`   üé≤ AI predicted ${probability}%, luck wasn't on our side`);
                    
                    showTimeEffect(timeLoss);
                }
            }, 1500);
        }

        function showOvertakeAnimation(targetPosition) {
            const indicator = document.createElement('div');
            indicator.style.position = 'fixed';
            indicator.style.top = '50%';
            indicator.style.left = '50%';
            indicator.style.transform = 'translate(-50%, -50%)';
            indicator.style.background = 'rgba(251, 146, 60, 0.95)';
            indicator.style.padding = '20px 30px';
            indicator.style.borderRadius = '15px';
            indicator.style.border = '3px solid #fb923c';
            indicator.style.fontSize = '24px';
            indicator.style.fontWeight = 'bold';
            indicator.style.color = '#fff';
            indicator.style.zIndex = '10000';
            indicator.style.boxShadow = '0 10px 40px rgba(251, 146, 60, 0.5)';
            indicator.innerHTML = `üèÅ OVERTAKING P${targetPosition}...`;
            document.body.appendChild(indicator);
            
            setTimeout(() => {
                indicator.remove();
            }, 1500);
        }

        function showTimeEffect(timeDelta) {
            const effect = document.createElement('div');
            effect.style.position = 'fixed';
            effect.style.top = '20%';
            effect.style.right = '20px';
            effect.style.padding = '15px 25px';
            effect.style.borderRadius = '10px';
            effect.style.fontSize = '28px';
            effect.style.fontWeight = 'bold';
            effect.style.zIndex = '10000';
            effect.style.transition = 'all 0.5s';
            effect.style.opacity = '1';
            
            if (timeDelta < 0) {
                effect.style.background = 'rgba(34, 197, 94, 0.95)';
                effect.style.border = '3px solid #22c55e';
                effect.style.color = '#fff';
                effect.innerHTML = `‚è±Ô∏è ${timeDelta.toFixed(3)}s`;
            } else {
                effect.style.background = 'rgba(239, 68, 68, 0.95)';
                effect.style.border = '3px solid #ef4444';
                effect.style.color = '#fff';
                effect.innerHTML = `‚è±Ô∏è +${timeDelta.toFixed(3)}s`;
            }
            
            document.body.appendChild(effect);
            
            setTimeout(() => {
                effect.style.opacity = '0';
                effect.style.transform = 'translateY(-50px)';
            }, 100);
            
            setTimeout(() => {
                effect.remove();
            }, 2000);
        }

        // ==================== UI UPDATES ====================
        function updateUI() {
            document.getElementById('currentLap').textContent = `${ourCar.currentLap}/${raceState.totalLaps}`;
            document.getElementById('position').textContent = `P${ourCar.position}`;
            document.getElementById('lapTime').textContent = formatTime(ourCar.lapTime);
            
            const totalTimeMins = Math.floor(ourCar.totalTime / 60);
            const totalTimeSecs = (ourCar.totalTime % 60).toFixed(3);
            document.getElementById('totalTime').textContent = `${totalTimeMins}:${totalTimeSecs.padStart(6, '0')}`;

            const tyreWearPct = Math.round(ourCar.tyreWear);
            const tyreWearBar = document.getElementById('tyreWearBar');
            tyreWearBar.style.width = `${tyreWearPct}%`;
            tyreWearBar.textContent = `${tyreWearPct}%`;
            tyreWearBar.className = `progress-fill ${tyreWearPct > 75 ? 'fill-red' : tyreWearPct > 50 ? 'fill-yellow' : 'fill-green'}`;

            const fuelPct = Math.round((ourCar.fuel / 110) * 100);
            const fuelBar = document.getElementById('fuelBar');
            fuelBar.style.width = `${fuelPct}%`;
            fuelBar.textContent = `${fuelPct}%`;
            fuelBar.className = `progress-fill ${fuelPct < 25 ? 'fill-red' : fuelPct < 50 ? 'fill-yellow' : 'fill-green'}`;

            document.getElementById('tempFL').textContent = `${Math.round(ourCar.tyreTemp.FL)}¬∞C`;
            document.getElementById('tempFR').textContent = `${Math.round(ourCar.tyreTemp.FR)}¬∞C`;
            document.getElementById('tempRL').textContent = `${Math.round(ourCar.tyreTemp.RL)}¬∞C`;
            document.getElementById('tempRR').textContent = `${Math.round(ourCar.tyreTemp.RR)}¬∞C`;

            updateCompetitorsList();
        }

        function updateCompetitorsList() {
            const allCars = [ourCar, ...competitors].sort((a, b) => a.position - b.position);
            
            const html = allCars.map(car => {
                const isOur = car.id === 'car_our';
                return `
                    <div class="car-info ${isOur ? 'our-car' : 'ai-car'}">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <strong>P${car.position} ${isOur ? '(YOU)' : car.id}</strong>
                            <span style="font-size: 0.85em; opacity: 0.8;">Lap ${car.currentLap}</span>
                        </div>
                        <div style="font-size: 0.8em; opacity: 0.7; margin-top: 3px;">
                            Tyre: ${Math.round(car.tyreWear)}% | Fuel: ${Math.round(car.fuel)}kg
                        </div>
                    </div>
                `;
            }).join('');

            document.getElementById('competitorsList').innerHTML = html;
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = (seconds % 60).toFixed(3);
            return `${mins}:${secs.padStart(6, '0')}`;
        }

        function logEvent(message) {
            const log = document.getElementById('eventLog');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('p');
            entry.textContent = `[${timestamp}] ${message}`;
            log.insertBefore(entry, log.firstChild);
            
            while (log.children.length > 20) {
                log.removeChild(log.lastChild);
            }
        }

        // ==================== CONFIGURATION ====================
        function showConfigModal() {
            document.getElementById('apiUrlInput').value = API_URL;
            document.getElementById('aiUrlInput').value = AI_URL;
            document.getElementById('startPositionInput').value = ourCar.position;
            document.getElementById('numCompetitorsInput').value = competitors.length;
            document.getElementById('configModal').style.display = 'flex';
        }

        function saveConfig() {
            API_URL = document.getElementById('apiUrlInput').value;
            AI_URL = document.getElementById('aiUrlInput').value;
            const startPos = parseInt(document.getElementById('startPositionInput').value);
            const numComps = parseInt(document.getElementById('numCompetitorsInput').value);

            ourCar.position = startPos;
            
            competitors = [];
            for (let i = 1; i <= numComps; i++) {
                competitors.push(createCompetitor(i));
            }

            logEvent(`‚öôÔ∏è Configuration saved`);
            logEvent(`   Track Backend: ${API_URL}`);
            logEvent(`   AI Backend: ${AI_URL}`);
            closeModal('configModal');
            updateUI();
        }

        function createCompetitor(id) {
            return {
                id: `car_${id}`,
                position: id < ourCar.position ? id : id + 1,
                progress: Math.random() * 0.1,
                speed: 288 + Math.random() * 4,
                tyreWear: Math.random() * 10,
                tyreTemp: {FL: 95, FR: 95, RL: 95, RR: 95},
                fuel: 110,
                lapTime: 0,
                currentLap: 1,
                paceMode: 'BALANCED',
                x: 0,
                y: 0,
                angle: 0
            };
        }

        function initCompetitors() {
            competitors = [];
            const numComps = parseInt(document.getElementById('numCompetitorsInput')?.value || 4);
            for (let i = 1; i <= numComps; i++) {
                competitors.push(createCompetitor(i));
            }
        }

        // ==================== INITIALIZATION ====================
        window.addEventListener('load', () => {
            initCompetitors();
            updateUI();
            logEvent('üèéÔ∏è F1 Quantum Strategy Simulator initialized');
            logEvent(`üî° Backend: ${API_URL}`);
            
            // Check backend connectivity
            fetch(`${API_URL}/api/analyze`, {method: 'OPTIONS'})
                .then(() => {
                    document.getElementById('opencvStatus').innerHTML = '‚úÖ Python Backend Connected';
                    document.getElementById('opencvStatus').style.background = 'rgba(34, 197, 94, 0.2)';
                    logEvent('‚úÖ Python backend ready for track processing');
                })
                .catch(() => {
                    document.getElementById('opencvStatus').innerHTML = '‚ö†Ô∏è Backend Offline - Check Connection';
                    document.getElementById('opencvStatus').style.background = 'rgba(239, 68, 68, 0.2)';
                    logEvent('‚ö†Ô∏è Python backend not reachable at ' + API_URL);
                });
        });
    </script>
    <script src="autonomous_client.js"></script>
</body>
</html>